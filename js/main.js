// Generated by CoffeeScript 1.7.1
(function() {
  $(function() {
    var WinningTileValue, arrayEqual, boardEqual, boardFull, buildBoard, collapseCells, colorCode, gameLost, gameWon, generateTile, getColumn, getRandomCell, getRow, mergeCells, move, moveIsValid, noValidMoves, ppArray, randomInt, randomValue, setColumn, setRow, showBoard, x, y, _i, _j;
    WinningTileValue = 2048;
    ppArray = function(array) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        row = array[_i];
        _results.push(console.log(row));
      }
      return _results;
    };
    this.board = [0, 1, 2, 3].map(function() {
      return [0, 1, 2, 3].map(function() {
        return 0;
      });
    });
    for (x = _i = 0; _i <= 3; x = ++_i) {
      this.board[x] = [];
      for (y = _j = 0; _j <= 3; y = ++_j) {
        this.board[x][y] = 0;
      }
    }
    randomInt = function(x) {
      return Math.floor(Math.random() * x);
    };
    buildBoard = function() {
      return [0, 1, 2, 3].map(function() {
        return [0, 1, 2, 3].map(function() {
          return 0;
        });
      });
    };
    getRandomCell = function() {
      return [randomInt(4), randomInt(4)];
    };
    randomValue = function() {
      var val, values;
      values = [2, 2, 2, 4];
      return val = values[randomInt(values.length)];
    };
    boardFull = function(board) {
      var _k, _l;
      for (x = _k = 0; _k <= 3; x = ++_k) {
        for (y = _l = 0; _l <= 3; y = ++_l) {
          if (board[x][y] === 0) {
            return false;
          }
        }
      }
      return true;
    };
    generateTile = function(board) {
      var val, _ref;
      if (!boardFull(board)) {
        val = randomValue();
        _ref = getRandomCell(), x = _ref[0], y = _ref[1];
        if (board[x][y] === 0) {
          return board[x][y] = val;
        } else {
          return generateTile(board);
        }
      }
    };
    ppArray(this.board);
    getRow = function(rowNumber, board) {
      var b, r, _ref;
      _ref = [rowNumber, board], r = _ref[0], b = _ref[1];
      return [b[r][0], b[r][1], b[r][2], b[r][3]];
    };
    getColumn = function(c, board) {
      var b;
      b = board;
      return [b[0][c], b[1][c], b[2][c], b[3][c]];
    };
    setRow = function(newArray, rowNumber, board) {
      return board[rowNumber] = newArray;
    };
    setColumn = function(newArray, columnNumber, board) {
      var b, c;
      c = columnNumber;
      b = board;
      return b[0][c] = newArray[0], b[1][c] = newArray[1], b[2][c] = newArray[2], b[3][c] = newArray[3], newArray;
    };
    arrayEqual = function(a, b) {
      var i, val, _k, _len;
      for (i = _k = 0, _len = a.length; _k < _len; i = ++_k) {
        val = a[i];
        if (val !== b[i]) {
          return false;
        }
      }
      return true;
    };
    boardEqual = function(a, b) {
      var i, row, _k, _len;
      for (i = _k = 0, _len = a.length; _k < _len; i = ++_k) {
        row = a[i];
        if (!arrayEqual(row, b[i])) {
          return false;
        }
      }
      return true;
    };
    moveIsValid = function(a, b) {
      return !boardEqual(a, b);
    };
    noValidMoves = function(board) {
      var direction, directions, newBoard, _k, _len;
      directions = ['up', 'down', 'left', 'right'];
      for (_k = 0, _len = directions.length; _k < _len; _k++) {
        direction = directions[_k];
        newBoard = move(board, direction);
        if (moveIsValid(newBoard, board)) {
          return false;
        }
      }
      return true;
    };
    mergeCells = function(originalCells, direction) {
      var cells, _k, _l, _m, _n, _ref, _ref1;
      cells = originalCells;
      switch (direction) {
        case 'left':
        case 'up':
          for (x = _k = 0; _k < 3; x = ++_k) {
            for (y = _l = _ref = x + 1; _ref <= 3 ? _l <= 3 : _l >= 3; y = _ref <= 3 ? ++_l : --_l) {
              if (cells[x] === 0) {
                break;
              } else if (cells[x] === cells[y]) {
                cells[x] *= 2;
                cells[y] = 0;
                break;
              } else if (cells[y] !== 0) {
                break;
              }
            }
          }
          break;
        case 'right':
        case 'down':
          for (x = _m = 3; _m > 0; x = --_m) {
            for (y = _n = _ref1 = x - 1; _ref1 <= 0 ? _n <= 0 : _n >= 0; y = _ref1 <= 0 ? ++_n : --_n) {
              if (cells[x] === 0) {
                break;
              } else if (cells[x] === cells[y]) {
                cells[x] *= 2;
                cells[y] = 0;
                break;
              } else if (cells[y] !== 0) {
                break;
              }
            }
          }
      }
      return cells;
    };
    collapseCells = function(originalCells, direction) {
      var cells, count, countZero, i, temp, _k, _l, _m;
      cells = originalCells;
      countZero = function(array) {
        var count, _k, _len;
        count = 0;
        for (_k = 0, _len = array.length; _k < _len; _k++) {
          x = array[_k];
          if (x === 0) {
            count = count + 1;
          }
        }
        return count;
      };
      count = countZero(originalCells);
      for (i = _k = 0; 0 <= count ? _k < count : _k > count; i = 0 <= count ? ++_k : --_k) {
        switch (direction) {
          case 'left':
          case 'up':
            for (x = _l = 0; _l < 3; x = ++_l) {
              temp = cells[x];
              if (cells[x] === 0) {
                cells[x] = cells[x + 1];
                cells[x + 1] = temp;
              }
            }
            break;
          case 'right':
          case 'down':
            for (x = _m = 3; _m > 0; x = --_m) {
              temp = cells[x];
              if (cells[x] === 0) {
                cells[x] = cells[x - 1];
                cells[x - 1] = temp;
              }
            }
        }
      }
      return cells;
    };
    gameLost = function(board) {
      return boardFull(board) && noValidMoves(board);
    };
    gameWon = function(board) {
      var cell, row, _k, _l, _len, _len1;
      for (_k = 0, _len = board.length; _k < _len; _k++) {
        row = board[_k];
        for (_l = 0, _len1 = row.length; _l < _len1; _l++) {
          cell = row[_l];
          if (cell >= WinningTileValue) {
            return true;
          }
        }
        false;
      }
    };
    showBoard = function(board) {
      var _k, _results;
      _results = [];
      for (x = _k = 0; _k <= 3; x = ++_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (y = _l = 0; _l <= 3; y = ++_l) {
            $(".r" + x + ".c" + y + " ").css("background-color", colorCode(board[x][y]));
            if (board[x][y] !== 0) {
              _results1.push($(".r" + x + ".c" + y + " > div").html(board[x][y]));
            } else {
              _results1.push($(".r" + x + ".c" + y + " > div").html(''));
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    colorCode = function(color) {
      switch (color) {
        case 0:
          return "#EEEFF2";
        case 0:
          return "#c3c5c8";
        case 2:
          return "#0f9dc8";
        case 4:
          return "#4360c8";
        case 8:
          return "#5d3bc8";
        case 16:
          return "#9947c8";
        case 32:
          return "#AB2E68";
        case 64:
          return "#c852a3";
        case 128:
          return "#c84446";
        case 256:
          return "#c8ac4c";
        case 512:
          return "#66c82e";
        case 1024:
          return "#00c83a";
        case 2048:
          return "#c86306";
      }
    };
    $(".tryAgain").click((function(_this) {
      return function(e) {
        _this.board = buildBoard();
        generateTile(_this.board);
        generateTile(_this.board);
        return showBoard(_this.board);
      };
    })(this));
    move = function(board, direction) {
      var c, i, newBoard, row, _k, _l, _m, _n;
      newBoard = buildBoard();
      for (i = _k = 0; _k <= 3; i = ++_k) {
        switch (direction) {
          case 'left':
            row = getRow(i, board);
            row = mergeCells(row, 'left');
            row = collapseCells(row, 'left');
            setRow(row, i, newBoard);
            break;
          case 'right':
            for (i = _l = 0; _l <= 3; i = ++_l) {
              row = getRow(i, board);
              row = mergeCells(row, 'right');
              row = collapseCells(row, 'right');
              setRow(row, i, newBoard);
            }
            break;
          case 'up':
            for (i = _m = 0; _m <= 3; i = ++_m) {
              row = getColumn(i, board);
              row = mergeCells(row, 'up');
              row = collapseCells(row, 'up');
              setColumn(row, i, newBoard);
            }
            break;
          case 'down':
            for (i = _n = 0; _n <= 3; i = ++_n) {
              c = getColumn(i, board);
              c = mergeCells(c, 'down');
              c = collapseCells(c, 'down');
              setColumn(c, i, newBoard);
            }
        }
      }
      return newBoard;
    };
    $('body').keydown((function(_this) {
      return function(e) {
        var direction, key, keys, newBoard;
        key = e.which;
        keys = [37, 38, 39, 40];
        if ($.inArray(key, keys) > -1) {
          e.preventDefault();
        } else {
          return;
        }
        direction = (function() {
          switch (key) {
            case 37:
              return 'left';
            case 38:
              return 'up';
            case 39:
              return 'right';
            case 40:
              return 'down';
          }
        })();
        newBoard = move(_this.board, direction);
        if (moveIsValid(newBoard, _this.board)) {
          _this.board = newBoard;
          generateTile(_this.board);
          showBoard(_this.board);
          if (gameLost(_this.board)) {
            return alert("Game Over");
          } else if (gameWon(_this.board)) {
            return alert("Yeah Buddy!");
          }
        }
      };
    })(this));
    this.board = buildBoard();
    generateTile(this.board);
    generateTile(this.board);
    return showBoard(this.board);
  });

}).call(this);

//# sourceMappingURL=main.map
